import confetti from 'canvas-confetti';

// --- Game State ---
let score = 100; // Start with some money to buy the first beans
let coffeePerSecond = 0;
let boardItems = {}; // Store items by slotId: { level: number, id: string }
let nextItemId = 0;
let currentBoardSize = 12; // e.g., 3x4 grid, can be upgraded
const MAX_BOARD_SIZE = 28;
let draggedItem = null; // { element: HTMLElement, slotId: string, itemData: object }
let isAutoGeneratorRunning = false;
let autoGeneratorStartTime = null;
let autoGeneratorAnimationId = null;
let autoGeneratorLevel = 0; // 0 = none, 1 = level 1 dropper, 2 = level 2 dropper etc.
let isHardMode = false;
let hasAutoMerger = false;
let isAutoMergeActive = false;
let hasAutoSeller = false;
let autoSellLevel = 1;
let qualityUpgradeLevel = 0;
let sellPriceMultiplier = 1.0;
let cpsUpgradeLevel = 0;
let cpsMultiplier = 1.0;
let clickerLevel = 1; // Level of coffee created by the "Make Coffee!" button
let unlockedAchievements = new Set();
let stats = {
    clicks: 0,
    merges: 0,
    itemsSold: 0,
    highestLevelReached: 0
};
let currentTheme = 'light'; // 'light' or 'dark'

// --- Configuration ---
const MAX_ITEM_LEVEL = 80; // Example max level
const SLOT_UPGRADE_BASE_COST = 200;
const SLOT_UPGRADE_COST_MULTIPLIER = 1.8;
const GENERATOR_LEVEL_UPGRADE_BASE_COST = 500;
const GENERATOR_LEVEL_UPGRADE_COST_MULTIPLIER = 3;
const CLICK_LEVEL_UPGRADE_BASE_COST = 1000;
const CLICK_LEVEL_UPGRADE_COST_MULTIPLIER = 3;
const AUTO_MERGER_COST = 10000;
const AUTO_SELLER_COST = 15000;
const QUALITY_UPGRADE_BASE_COST = 20000;
const QUALITY_UPGRADE_COST_MULTIPLIER = 2.5;
const CPS_UPGRADE_BASE_COST = 25000;
const CPS_UPGRADE_COST_MULTIPLIER = 3.5;
const ITEM_VALUES = { // Points awarded for merging *to* this level
    1: 0, // Base item
    2: 2,
    3: 8,
    4: 25,
    5: 100,
    6: 350,
    7: 1200,
    8: 3500,
    9: 10000,
    10: 30000,
    11: 950000,
    12: 3000000,
    13: 9500000,
    14: 30000000,
    15: 100000000,
    16: 330000000,
    17: 1100000000,
    18: 3500000000,
    19: 11000000000,
    20: 35000000000,
    21: 110000000000,
    22: 360000000000,
    23: 1200000000000,
    24: 4000000000000,
    25: 13000000000000,
    26: 42000000000000,
    27: 140000000000000,
    28: 500000000000000,
    29: 1800000000000000,
    30: 6500000000000000,
    31: 2.3e16,
    32: 8.1e16,
    33: 2.8e17,
    34: 9.8e17,
    35: 3.4e18,
    36: 1.2e19,
    37: 4.2e19,
    38: 1.5e20,
    39: 5.2e20,
    40: 1.8e21,
    41: 6.3e21,
    42: 2.2e22,
    43: 7.7e22,
    44: 2.7e23,
    45: 9.4e23,
    46: 3.3e24,
    47: 1.2e25,
    48: 4.2e25,
    49: 1.5e26,
    50: 5.1e26,
    51: 1.8e27,
    52: 6.3e27,
    53: 2.2e28,
    54: 7.7e28,
    55: 2.7e29,
    56: 9.4e29,
    57: 3.3e30,
    58: 1.2e31,
    59: 4.1e31,
    60: 1.4e32,
    61: 5.0e32,
    62: 1.7e33,
    63: 6.1e33,
    64: 2.1e34,
    65: 7.4e34,
    66: 2.6e35,
    67: 9.1e35,
    68: 3.2e36,
    69: 1.1e37,
    70: 3.9e37,
    71: 1.4e38,
    72: 4.8e38,
    73: 1.7e39,
    74: 5.8e39,
    75: 2.0e40,
    76: 7.1e40,
    77: 2.5e41,
    78: 8.7e41,
    79: 3.0e42,
    80: 1.1e43,
};

const ITEM_SELL_PRICES = { // Points gained for selling an item of this level
    1: 15, // Less than cost to prevent simple buy/sell exploit
    2: 50,
    3: 150,
    4: 450,
    5: 1350,
    6: 4000,
    7: 12000,
    8: 35000,
    9: 100000,
    10: 300000,
    11: 950000,
    12: 3000000,
    13: 9500000,
    14: 30000000,
    15: 100000000,
    16: 330000000,
    17: 1100000000,
    18: 3500000000,
    19: 11000000000,
    20: 35000000000,
    21: 110000000000,
    22: 360000000000,
    23: 1200000000000,
    24: 4000000000000,
    25: 13000000000000,
    26: 42000000000000,
    27: 140000000000000,
    28: 500000000000000,
    29: 1800000000000000,
    30: 6500000000000000,
    31: 2.3e16,
    32: 8.1e16,
    33: 2.8e17,
    34: 9.8e17,
    35: 3.4e18,
    36: 1.2e19,
    37: 4.2e19,
    38: 1.5e20,
    39: 5.2e20,
    40: 1.8e21,
    41: 6.3e21,
    42: 2.2e22,
    43: 7.7e22,
    44: 2.7e23,
    45: 9.4e23,
    46: 3.3e24,
    47: 1.2e25,
    48: 4.2e25,
    49: 1.5e26,
    50: 5.1e26,
    51: 1.8e27,
    52: 6.3e27,
    53: 2.2e28,
    54: 7.7e28,
    55: 2.7e29,
    56: 9.4e29,
    57: 3.3e30,
    58: 1.2e31,
    59: 4.1e31,
    60: 1.4e32,
    61: 5.0e32,
    62: 1.7e33,
    63: 6.1e33,
    64: 2.1e34,
    65: 7.4e34,
    66: 2.6e35,
    67: 9.1e35,
    68: 3.2e36,
    69: 1.1e37,
    70: 3.9e37,
    71: 1.4e38,
    72: 4.8e38,
    73: 1.7e39,
    74: 5.8e39,
    75: 2.0e40,
    76: 7.1e40,
    77: 2.5e41,
    78: 8.7e41,
    79: 3.0e42,
    80: 1.1e43,
};

const ITEM_CPS = { // CPS generated by items of this level
    1: 0.0,
    2: 0.1,
    3: 0.5,
    4: 2.0,
    5: 7.5,
    6: 25.0,
    7: 90,
    8: 300,
    9: 1000,
    10: 3500,
    11: 12000,
    12: 40000,
    13: 130000,
    14: 450000,
    15: 1500000,
    16: 5000000,
    17: 16500000,
    18: 53000000,
    19: 170000000,
    20: 550000000,
    21: 1700000000,
    22: 5600000000,
    23: 18000000000,
    24: 60000000000,
    25: 200000000000,
    26: 660000000000,
    27: 2200000000000,
    28: 7500000000000,
    29: 26000000000000,
    30: 90000000000000,
    31: 3.1e14,
    32: 1.1e15,
    33: 3.7e15,
    34: 1.3e16,
    35: 4.4e16,
    36: 1.5e17,
    37: 5.1e17,
    38: 1.7e18,
    39: 5.8e18,
    40: 2.0e19,
    41: 6.8e19,
    42: 2.3e20,
    43: 7.8e20,
    44: 2.7e21,
    45: 9.2e21,
    46: 3.1e22,
    47: 1.1e23,
    48: 3.7e23,
    49: 1.3e24,
    50: 4.4e24,
    51: 1.5e25,
    52: 5.1e25,
    53: 1.7e26,
    54: 5.8e26,
    55: 2.0e27,
    56: 6.8e27,
    57: 2.3e28,
    58: 7.8e28,
    59: 2.7e29,
    60: 9.2e29,
    61: 3.1e30,
    62: 1.1e31,
    63: 3.7e31,
    64: 1.3e32,
    65: 4.4e32,
    66: 1.5e33,
    67: 5.1e33,
    68: 1.7e34,
    69: 5.8e34,
    70: 2.0e35,
    71: 6.8e35,
    72: 2.3e36,
    73: 7.8e36,
    74: 2.7e37,
    75: 9.2e37,
    76: 3.1e38,
    77: 1.1e39,
    78: 3.7e39,
    79: 1.3e40,
    80: 4.4e40,
}

const AUTO_GENERATOR_INTERVAL_MS = 5000; // 5 seconds for level 1

const ACHIEVEMENTS = {
    'click_1': {
        name: "First Click",
        description: "You've started your coffee journey.",
        check: () => stats.clicks >= 1
    },
    'click_100': {
        name: "Caffeine Jitters",
        description: "Click the main button 100 times.",
        check: () => stats.clicks >= 100
    },
    'click_1000': {
        name: "Carpal Tunnel Claimant",
        description: "Click the main button 1,000 times.",
        check: () => stats.clicks >= 1000
    },
    'merge_1': {
        name: "It's a Match!",
        description: "Perform your first merge.",
        check: () => stats.merges >= 1
    },
    'merge_50': {
        name: "Master Blender",
        description: "Perform 50 merges.",
        check: () => stats.merges >= 50
    },
    'merge_500': {
        name: "Merge Maniac",
        description: "Perform 500 merges.",
        check: () => stats.merges >= 500
    },
    'level_5': {
        name: "Latte Artist",
        description: "Create a Level 5 item (Professional Roast).",
        check: () => stats.highestLevelReached >= 5
    },
    'level_10': {
        name: "Coffee Magnate",
        description: "Create a Level 10 item (Golden Bean).",
        check: () => stats.highestLevelReached >= 10
    },
    'level_20': {
        name: "Galaxy Brain Barista",
        description: "Create a Level 20 item (Cosmic Coffee).",
        check: () => stats.highestLevelReached >= 20
    },
    'level_30': {
        name: "The Final Frontier",
        description: "Create a Level 30 item (The Ultimate Bean).",
        check: () => stats.highestLevelReached >= 30
    },
    'score_1k': {
        name: "Pocket Change",
        description: "Have 1,000 Coffee Points on hand.",
        check: () => score >= 1000
    },
    'score_1m': {
        name: "Coffee Millionaire",
        description: "Have 1,000,000 Coffee Points on hand.",
        check: () => score >= 1000000
    },
    'score_1b': {
        name: "Billionaire Barista",
        description: "Have 1,000,000,000 Coffee Points on hand.",
        check: () => score >= 1e9
    },
    'sell_1': {
        name: "First Sale",
        description: "Sell your first item.",
        check: () => stats.itemsSold >= 1
    },
    'sell_100': {
        name: "Business is Booming",
        description: "Sell 100 items.",
        check: () => stats.itemsSold >= 100
    },
    'upgrade_dropper': {
        name: "Automation",
        description: "Purchase the Auto Bean Dropper.",
        check: () => autoGeneratorLevel > 0
    },
    'upgrade_merger': {
        name: "Hands-Free",
        description: "Purchase the Auto-Merger.",
        check: () => hasAutoMerger
    },
    'board_max': {
        name: "Territory Master",
        description: "Expand your board to the maximum size.",
        check: () => currentBoardSize >= MAX_BOARD_SIZE
    },
    'hard_mode_start': {
        name: "For the Pros",
        description: "Start a game in Hard Mode.",
        check: () => isHardMode
    }
};

// --- DOM Elements ---
const scoreDisplay = document.getElementById('score');
const cpsDisplay = document.getElementById('cps');
const clickerButton = document.getElementById('clicker-button');
const mergeBoard = document.getElementById('merge-board');
const clickFeedbackContainer = document.getElementById('click-feedback-container');
const autoGeneratorUpgradeButton = document.getElementById('auto-generator-upgrade');
const autoGeneratorStatusContainer = document.getElementById('auto-generator-status');
const autoGeneratorLevelDisplay = document.getElementById('auto-generator-level-display');
const dropperProgressContainer = document.getElementById('dropper-progress-container');
const dropperProgressBar = document.getElementById('dropper-progress-bar');
const upgradeGeneratorLevelButton = document.getElementById('upgrade-generator-level');
const upgradeClickLevelButton = document.getElementById('upgrade-click-level');
const buySlotUpgradeButton = document.getElementById('buy-slot-upgrade');
const buyAutoMergerButton = document.getElementById('buy-auto-merger-upgrade');
const autoMergerToggleContainer = document.getElementById('auto-merger-toggle-container');
const autoMergerToggle = document.getElementById('auto-merger-toggle');
const buyAutoSellerButton = document.getElementById('buy-auto-seller-upgrade');
const autoSellerContainer = document.getElementById('auto-seller-container');
const autoSellLevelSelect = document.getElementById('auto-sell-level');
const qualityUpgradeButton = document.getElementById('upgrade-quality');
const cpsUpgradeButton = document.getElementById('upgrade-cps');
const sellZone = document.getElementById('sell-zone');
const clickerButtonText = clickerButton.querySelector('span');
const resetButton = document.getElementById('reset-button');
const themeToggleButton = document.getElementById('theme-toggle-button');
const hardModeButton = document.getElementById('hard-mode-button');
const achievementsButton = document.getElementById('achievements-button');
const achievementsModal = document.getElementById('achievements-modal');
const closeModalButton = document.getElementById('close-modal-button');
const achievementsList = document.getElementById('achievements-list');
const achievementToastContainer = document.getElementById('achievement-toast-container');

// --- Audio ---
let audioContext;
const audioBuffers = {};

async function setupAudio() {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    // Pre-load sounds
    await loadSound('sell.mp3');
    await loadSound('error.mp3');
}

async function loadSound(url) {
    try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        audioBuffers[url] = audioBuffer;
    } catch(e) {
        console.error(`Error loading sound: ${url}`, e);
    }
}

function playSound(url) {
    if (!audioContext || !audioBuffers[url]) return;
    // Resume context on user gesture
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffers[url];
    source.connect(audioContext.destination);
    source.start(0);
}

// --- Initialization ---
function initGame() {
    loadGame(); // Load saved state if available
    updateModeDisplay();
    updateScoreDisplay();
    updateCPSDisplay();
    updateUpgradeButtons();
    setInterval(updateGame, 1000); // Main game loop (for CPS)

    clickerButton.addEventListener('click', handleClick);
    autoGeneratorUpgradeButton.addEventListener('click', buyAutoGenerator);
    upgradeGeneratorLevelButton.addEventListener('click', upgradeGeneratorLevel);
    upgradeClickLevelButton.addEventListener('click', upgradeClickerLevel);
    buySlotUpgradeButton.addEventListener('click', buySlot);
    buyAutoMergerButton.addEventListener('click', buyAutoMerger);
    autoMergerToggle.addEventListener('change', toggleAutoMerger);
    buyAutoSellerButton.addEventListener('click', buyAutoSeller);
    autoSellLevelSelect.addEventListener('change', updateAutoSellLevel);
    qualityUpgradeButton.addEventListener('click', buyQualityUpgrade);
    cpsUpgradeButton.addEventListener('click', buyCpsUpgrade);
    initResetButton();
    hardModeButton.addEventListener('click', toggleHardMode);
    themeToggleButton.addEventListener('click', toggleTheme);

    // Achievement modal listeners
    achievementsButton.addEventListener('click', openAchievementsModal);
    closeModalButton.addEventListener('click', closeAchievementsModal);
    window.addEventListener('click', (event) => {
        if (event.target === achievementsModal) {
            closeAchievementsModal();
        }
    });

    // Sell Zone event listeners
    sellZone.addEventListener('dragover', handleDragOverSell);
    sellZone.addEventListener('dragenter', handleDragEnterSell);
    sellZone.addEventListener('dragleave', handleDragLeaveSell);
    sellZone.addEventListener('drop', handleDropSell);

    // Prevent default drag behavior to allow dropping
    document.addEventListener('dragover', (event) => {
        event.preventDefault();
    });
    // Initialize generator if loaded state has it active
    if (autoGeneratorLevel > 0) {
        startAutoGenerator();
    }
}

// --- Reset Logic ---
let resetTimer = null;
const RESET_HOLD_DURATION = 3000; // 3 seconds

function initResetButton() {
    resetButton.addEventListener('mousedown', startResetTimer);
    resetButton.addEventListener('mouseup', cancelResetTimer);
    resetButton.addEventListener('mouseleave', cancelResetTimer);
    resetButton.addEventListener('touchstart', (e) => { e.preventDefault(); startResetTimer(); });
    resetButton.addEventListener('touchend', (e) => { e.preventDefault(); cancelResetTimer(); });
}

function startResetTimer() {
    if (resetTimer) return;
    
    resetButton.textContent = "Hold...";

    resetTimer = setTimeout(() => {
        performReset();
        resetButton.textContent = "Done!";
        setTimeout(() => {
            resetButton.textContent = "🔄";
        }, 1500);
    }, RESET_HOLD_DURATION);
}

function cancelResetTimer() {
    if (resetTimer) {
        clearTimeout(resetTimer);
        resetTimer = null;
        resetButton.textContent = "🔄";
    }
}

function performReset() {
    console.log("--- RESETTING GAME ---");
    // 1. Clear local storage
    localStorage.removeItem(SAVE_KEY);

    // 2. Reset the game state
    const hardModeStateBeforeReset = isHardMode; // Preserve hard mode setting
    resetGameState();
    isHardMode = hardModeStateBeforeReset; // Restore it after reset
    
    // 3. Clear any running intervals
    stopAutoGenerator();
    
    // 4. Update all UI elements
    updateModeDisplay();
    updateScoreDisplay();
    updateCPSDisplay();
    updateUpgradeButtons();
    console.log("Game has been reset.");
}

function createBoardSlots() {
    mergeBoard.innerHTML = ''; // Clear existing slots
    for (let i = 0; i < currentBoardSize; i++) {
        const slot = document.createElement('div');
        slot.classList.add('board-slot');
        slot.id = `slot-${i}`;
        slot.addEventListener('dragover', handleDragOver);
        slot.addEventListener('dragenter', handleDragEnter);
        slot.addEventListener('dragleave', handleDragLeave);
        slot.addEventListener('drop', handleDrop);
        mergeBoard.appendChild(slot);
        if (boardItems[slot.id] === undefined) { // Check if it's a new slot being added
            boardItems[slot.id] = null; // Initialize new slot as empty
        }
    }
}

// --- Hard Mode Logic ---
function toggleHardMode() {
    const targetMode = isHardMode ? "Normal" : "Hard";
    if (window.confirm(`Switching to ${targetMode} Mode will reset all progress. Are you sure?`)) {
        isHardMode = !isHardMode; // Set the new mode
        performReset();           // Reset progress
        saveGame();               // Save the new, empty state with the correct mode
    }
}

function updateModeDisplay() {
    const gameContainer = document.getElementById('game-container');
    if (isHardMode) {
        hardModeButton.textContent = "Switch to Normal Mode";
        gameContainer.classList.add('hard-mode');
    } else {
        hardModeButton.textContent = "Play Hard Mode";
        gameContainer.classList.remove('hard-mode');
    }
}

// --- Theme Logic ---
function applyTheme(theme) {
    document.body.classList.remove('light-mode', 'dark-mode');
    document.body.classList.add(`${theme}-mode`);
    themeToggleButton.textContent = theme === 'light' ? '🌓' : '☀️';
    currentTheme = theme;
}

function toggleTheme() {
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    applyTheme(newTheme);
    saveGame(); // Save theme preference
}

// --- Core Game Logic ---

function getClickCost() {
    // A bit more than the sell price of the item it creates, growing with level.
    // Base cost for level 1 is hardcoded to 25.
    const baseCost = 25;
    if (clickerLevel === 1) return baseCost;
    // For higher levels, use a formula based on the base cost and level
    return Math.floor(baseCost * Math.pow(clickerLevel, 2.5));
}

function handleClick() {
    // Resume audio context on first user interaction
    if (!audioContext) {
        setupAudio();
    }
    const currentClickCost = getClickCost();

    if (score >= currentClickCost) {
        addScore(-currentClickCost);
        stats.clicks++; // Track clicks for achievements
        updateScoreDisplay(); // Update immediately after purchase
        if (spawnItem(clickerLevel)) { // Spawn an item of the current clicker level
             animateClickFeedback(`-${currentClickCost} Pts`, clickerButton, true);
        } else {
            // Refund if spawn failed
            addScore(currentClickCost);
            stats.clicks--; // Revert click count if spawn failed
            updateScoreDisplay();
        }
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", clickerButton, true);
        playSound('error.mp3');
    }
}

function spawnItem(level, targetSlotId = null) {
    let emptySlotId = targetSlotId;

    if (!emptySlotId) {
        // Find the first empty slot
        for (let i = 0; i < currentBoardSize; i++) {
            const slotId = `slot-${i}`;
            if (!boardItems[slotId]) {
                emptySlotId = slotId;
                break;
            }
        }
    }

    if (emptySlotId && boardItems[emptySlotId] === null) { // Double check target is empty
        const newItemId = `item-${nextItemId++}`;
        const newItemData = { level: level, id: newItemId };
        boardItems[emptySlotId] = newItemData;
        renderItem(emptySlotId, newItemData);
        updateCPSDisplay(); // Update CPS when item is added
        updateUpgradeButtons(); // Costs might now be affordable/un-affordable
        saveGame();
        runAutoSell(); // Check for auto-sells after a new item appears
        runAutoMerge(); // Check for merges after a new item appears
        if (newItemData.level > stats.highestLevelReached) {
            stats.highestLevelReached = newItemData.level;
        }
        return true; // Item spawned successfully
    } else {
        console.warn("No empty slot found or target slot occupied!");
        animateClickFeedback("Board Full!", clickerButton, true);
        playSound('error.mp3');
        return false; // Failed to spawn
    }
}

function renderItem(slotId, itemData) {
    const slot = document.getElementById(slotId);
    if (!slot || !itemData) return;

    // Clear previous item if any (important for merging/moving)
    const existingItemElement = slot.querySelector('.coffee-item-container');
    if (existingItemElement) {
        existingItemElement.remove();
    }

    const itemContainer = document.createElement('div');
    itemContainer.classList.add('coffee-item-container');
    itemContainer.id = itemData.id;
    itemContainer.draggable = true;
    itemContainer.dataset.level = itemData.level;
    itemContainer.dataset.slotId = slotId; // Store slot ID for reference

    const svgUse = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    svgUse.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#item-level-${itemData.level}`);

    const svgWrapper = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgWrapper.setAttribute('viewBox', '0 0 50 50'); // Match SVG def viewbox
    svgWrapper.appendChild(svgUse);

    itemContainer.appendChild(svgWrapper);

    itemContainer.addEventListener('dragstart', handleDragStart);
    itemContainer.addEventListener('dragend', handleDragEnd);

    slot.appendChild(itemContainer);
}

function renderAllItems() {
    for (const slotId in boardItems) {
        if (boardItems[slotId]) {
            renderItem(slotId, boardItems[slotId]);
        }
    }
}

function removeItem(slotId) {
    const slot = document.getElementById(slotId);
    if (slot && boardItems[slotId]) {
        const itemElement = slot.querySelector(`#${boardItems[slotId].id}`);
        if (itemElement) {
            itemElement.remove();
        }
        boardItems[slotId] = null;
        updateCPSDisplay(); // Update CPS when item is removed
        updateUpgradeButtons();
        // NOTE: saveGame() is not called here directly. The functions that call removeItem (like sell or merge) will handle saving.
    }
}

function moveItem(sourceSlotId, targetSlotId) {
    if (sourceSlotId === targetSlotId || !boardItems[sourceSlotId] || boardItems[targetSlotId]) {
        console.warn("Invalid move:", sourceSlotId, "to", targetSlotId);
        return; // Cannot move to the same slot or occupied slot
    }

    const itemData = boardItems[sourceSlotId];
    boardItems[targetSlotId] = itemData;
    boardItems[sourceSlotId] = null;

    // Re-render in new slot and clear old one visually
    const sourceSlot = document.getElementById(sourceSlotId);
    const itemElement = sourceSlot.querySelector(`#${itemData.id}`);
    if (itemElement) itemElement.remove(); // Remove from old slot DOM

    renderItem(targetSlotId, itemData); // Render in new slot DOM

    saveGame();
    runAutoMerge(); // Check for merges in case item was moved next to a pair
}

function mergeItems(sourceSlotId, targetSlotId) {
    const sourceItem = boardItems[sourceSlotId];
    const targetItem = boardItems[targetSlotId];

    if (!sourceItem || !targetItem || sourceItem.level !== targetItem.level) {
        console.warn("Merge condition not met");
        return false;
    }

    const currentLevel = sourceItem.level;
    if (currentLevel >= MAX_ITEM_LEVEL) {
        console.warn("Cannot merge max level item");
         // Maybe provide visual feedback like a shake?
        return false; // Don't merge max level items
    }

    const nextLevel = currentLevel + 1;

    // Track for achievements
    stats.merges++;
    if (nextLevel > stats.highestLevelReached) {
        stats.highestLevelReached = nextLevel;
    }

    // 1. Remove the source item completely
    const sourceItemData = boardItems[sourceSlotId];
    // Remove without saving, as we save after the whole operation
    const slot = document.getElementById(sourceSlotId);
    if(slot) {
        const itemElement = slot.querySelector(`#${sourceItemData.id}`);
        if(itemElement) itemElement.remove();
    }
    boardItems[sourceSlotId] = null;

    // 2. Upgrade the target item
    const upgradedItemData = { ...targetItem, level: nextLevel }; // Keep ID of target item
    boardItems[targetSlotId] = upgradedItemData;
    renderItem(targetSlotId, upgradedItemData); // Re-render target item with new level

    // 3. Award points & Confetti!
    const pointsGained = ITEM_VALUES[nextLevel] || 0;
    addScore(pointsGained);
    animateClickFeedback(`+${formatNumber(pointsGained)} Pts!`, document.getElementById(targetSlotId)); // Show points near merge location
    shootConfetti(document.getElementById(targetSlotId));
    playSound('sell.mp3'); // Merging is like a successful transaction

    // 4. Update CPS
    updateCPSDisplay();
    saveGame();
    runAutoSell(); // Check if the new merged item should be sold
    runAutoMerge(); // Check for a chain reaction of merges
    checkAllAchievements();
    return true;
}

function updateGame() {
    // Calculate total CPS from items on board
    let currentCPS = 0;
    for (const slotId in boardItems) {
        if (boardItems[slotId]) {
            const level = boardItems[slotId].level;
            currentCPS += ITEM_CPS[level] || 0;
        }
    }
    
    // Apply CPS multiplier
    currentCPS *= cpsMultiplier;

    // Apply CPS gain
    addScore(currentCPS); // Add score per second

    // Update display if CPS changed
    if (currentCPS !== coffeePerSecond) {
        coffeePerSecond = currentCPS;
        updateCPSDisplay();
    }

    // Update score display every second regardless (it might change fractionally)
     updateScoreDisplay(); // Update score display frequently
     updateUpgradeButtons(); // Check if upgrades affordable
     checkAllAchievements();
}

function addScore(amount) {
    score += amount;
    // Don't call updateScoreDisplay here for performance, let the interval handle it
    // or only update if the integer part changes significantly
}

function updateScoreDisplay() {
    scoreDisplay.textContent = formatNumber(score);
    // Update clicker button text based on cost
    const cost = getClickCost();
    clickerButtonText.textContent = `Make Coffee! (${formatNumber(cost)} Pts)`;
}

function updateCPSDisplay() {
     let totalCPS = 0;
    for (const slotId in boardItems) {
        if (boardItems[slotId]) {
            const level = boardItems[slotId].level;
            totalCPS += ITEM_CPS[level] || 0;
        }
    }
    totalCPS *= cpsMultiplier; // Apply multiplier
    coffeePerSecond = totalCPS; // Update the global state
    cpsDisplay.textContent = totalCPS < 1000 ? totalCPS.toFixed(1) : formatNumber(totalCPS);
}

// --- Drag and Drop Handlers ---

function handleDragStart(event) {
    const itemContainer = event.target;
    // Check if the target is actually the draggable container
    if (!itemContainer.classList.contains('coffee-item-container')) return;

    // Resume audio context on first drag
    if (!audioContext) {
        setupAudio();
    }

    draggedItem = {
        element: itemContainer,
        slotId: itemContainer.dataset.slotId,
        itemData: boardItems[itemContainer.dataset.slotId] // Get data from boardItems
    };
    event.dataTransfer.setData('text/plain', draggedItem.slotId); // Pass slot ID
    event.dataTransfer.effectAllowed = 'move';
    // Optional: slightly delay adding class for smoother visual transition
    setTimeout(() => itemContainer.classList.add('dragging'), 0);
}

function handleDragEnd(event) {
    if (draggedItem && draggedItem.element) {
        draggedItem.element.classList.remove('dragging');
    }
     // Clear ghost image immediately
    event.target.style.opacity = ''; // Restore opacity if needed
    clearDropHighlights();
    draggedItem = null;
}

function handleDragOver(event) {
    event.preventDefault(); // Necessary to allow dropping
     const targetSlot = event.target.closest('.board-slot');
     if (targetSlot && draggedItem && targetSlot.id !== draggedItem.slotId) {
         targetSlot.classList.add('over'); // Highlight potential drop target
     }
}

function handleDragEnter(event) {
    event.preventDefault();
    const targetSlot = event.target.closest('.board-slot');
    if (targetSlot && draggedItem && targetSlot.id !== draggedItem.slotId) {
       targetSlot.classList.add('over');
    }
}

function handleDragLeave(event) {
    const targetSlot = event.target.closest('.board-slot');
    if (targetSlot) {
        targetSlot.classList.remove('over');
    }
     // Check if we are leaving the slot entirely or just moving over its child item
    const relatedTarget = event.relatedTarget;
    if (targetSlot && relatedTarget && !targetSlot.contains(relatedTarget)) {
       targetSlot.classList.remove('over');
    } else if (!relatedTarget) { // Leaving the browser window / drop zone
         targetSlot.classList.remove('over');
    }
}

function handleDrop(event) {
    event.preventDefault();
    clearDropHighlights();

    const targetSlotElement = event.target.closest('.board-slot');
    if (!targetSlotElement || !draggedItem) return; // No valid drop target or item

    const sourceSlotId = draggedItem.slotId;
    const targetSlotId = targetSlotElement.id;

    // Prevent dropping onto the same slot
    if (sourceSlotId === targetSlotId) return;

    const sourceItem = boardItems[sourceSlotId];
    const targetItem = boardItems[targetSlotId];

    if (targetItem) { // Target slot is occupied, attempt merge
        if (sourceItem && sourceItem.level === targetItem.level) {
            mergeItems(sourceSlotId, targetSlotId);
        } else {
             // Cannot merge (different levels or trying to drop on occupied non-mergeable)
             // Optional: Add visual feedback like shaking the target slot
             console.log("Cannot merge or invalid drop");
             // Return dragged item visually to original position (handled by dragend)
        }
    } else { // Target slot is empty, move the item
        moveItem(sourceSlotId, targetSlotId);
    }

    // Dragged item is cleared in handleDragEnd
}

function clearDropHighlights() {
    document.querySelectorAll('.board-slot.over').forEach(slot => {
        slot.classList.remove('over');
    });
    sellZone.classList.remove('over');
}

// --- Sell Zone Drag Handlers ---

function handleDragOverSell(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
}

function handleDragEnterSell(event) {
    event.preventDefault();
    if (draggedItem) {
        sellZone.classList.add('over');
    }
}

function handleDragLeaveSell(event) {
    const relatedTarget = event.relatedTarget;
    // Check if we are leaving the sell zone entirely
    if (relatedTarget && !sellZone.contains(relatedTarget)) {
       sellZone.classList.remove('over');
    } else if (!relatedTarget) { // Leaving the browser window
        sellZone.classList.remove('over');
    }
}

function handleDropSell(event) {
    event.preventDefault();
    if (!draggedItem) return;

    const { slotId, itemData } = draggedItem;
    const sellPrice = Math.floor((ITEM_SELL_PRICES[itemData.level] || 0) * sellPriceMultiplier);

    addScore(sellPrice);
    updateScoreDisplay();
    animateClickFeedback(`+${formatNumber(sellPrice)} Pts!`, sellZone, true);
    playSound('sell.mp3');

    // Remove item from board
    removeItem(slotId);
    stats.itemsSold++;
    saveGame(); // Save after successful sell
    checkAllAchievements();

    // Clean up drag state
    sellZone.classList.remove('over');
    draggedItem = null; // Important: nullify draggedItem
}

// --- Upgrades ---

function getClickerLevelUpgradeCost() {
    // The cost is based on how many upgrades have been purchased (clickerLevel - 1)
    const purchasedUpgrades = clickerLevel - 1;
    return Math.floor(CLICK_LEVEL_UPGRADE_BASE_COST * Math.pow(CLICK_LEVEL_UPGRADE_COST_MULTIPLIER, purchasedUpgrades));
}

function getSlotUpgradeCost() {
    const purchasedSlots = currentBoardSize - 12; // Base size is 12
    return Math.floor(SLOT_UPGRADE_BASE_COST * Math.pow(SLOT_UPGRADE_COST_MULTIPLIER, purchasedSlots));
}

function getGeneratorLevelUpgradeCost() {
    const purchasedUpgrades = autoGeneratorLevel - 1; // First level is bought, not upgraded
    return Math.floor(GENERATOR_LEVEL_UPGRADE_BASE_COST * Math.pow(GENERATOR_LEVEL_UPGRADE_COST_MULTIPLIER, purchasedUpgrades));
}

function getQualityUpgradeCost() {
    return Math.floor(QUALITY_UPGRADE_BASE_COST * Math.pow(QUALITY_UPGRADE_COST_MULTIPLIER, qualityUpgradeLevel));
}

function getCpsUpgradeCost() {
    return Math.floor(CPS_UPGRADE_BASE_COST * Math.pow(CPS_UPGRADE_COST_MULTIPLIER, cpsUpgradeLevel));
}

function upgradeClickerLevel() {
    const cost = getClickerLevelUpgradeCost();
    if (score >= cost) {
        addScore(-cost);
        clickerLevel++;
        updateScoreDisplay();
        updateUpgradeButtons();
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", upgradeClickLevelButton, true);
    }
}

function buyAutoMerger() {
    if (hasAutoMerger) return;

    if (score >= AUTO_MERGER_COST) {
        addScore(-AUTO_MERGER_COST);
        hasAutoMerger = true;
        isAutoMergeActive = true; // Turn it on by default
        autoMergerToggle.checked = true;
        updateScoreDisplay();
        updateUpgradeButtons();
        runAutoMerge(); // Run it once on purchase
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", buyAutoMergerButton, true);
    }
}

function toggleAutoMerger() {
    isAutoMergeActive = autoMergerToggle.checked;
    if(isAutoMergeActive) {
        runAutoMerge(); // Run check when toggled on
    }
    saveGame();
}

function buyAutoSeller() {
    if (hasAutoSeller) return;

    if (score >= AUTO_SELLER_COST) {
        addScore(-AUTO_SELLER_COST);
        hasAutoSeller = true;
        updateScoreDisplay();
        updateUpgradeButtons();
        runAutoSell();
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", buyAutoSellerButton, true);
    }
}

function updateAutoSellLevel(event) {
    autoSellLevel = parseInt(event.target.value);
    runAutoSell();
    saveGame();
    checkAllAchievements();
}

function buyQualityUpgrade() {
    const cost = getQualityUpgradeCost();
    if (score >= cost) {
        addScore(-cost);
        qualityUpgradeLevel++;
        sellPriceMultiplier += 0.05; // Add 5%
        updateScoreDisplay();
        updateUpgradeButtons();
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", qualityUpgradeButton, true);
    }
}

function buyCpsUpgrade() {
    const cost = getCpsUpgradeCost();
    if (score >= cost) {
        addScore(-cost);
        cpsUpgradeLevel++;
        cpsMultiplier += 0.05; // Add 5%
        updateScoreDisplay();
        updateCPSDisplay(); // CPS is affected directly
        updateUpgradeButtons();
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", cpsUpgradeButton, true);
    }
}

function buySlot() {
    if (currentBoardSize >= MAX_BOARD_SIZE) return;

    const cost = getSlotUpgradeCost();
    if (score >= cost) {
        addScore(-cost);
        currentBoardSize++;
        
        // Re-create board and re-render items
        createBoardSlots();
        renderAllItems();

        updateScoreDisplay();
        updateUpgradeButtons(); // Costs might now be affordable/un-affordable
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", buySlotUpgradeButton, true);
    }
}

function upgradeGeneratorLevel() {
    const cost = getGeneratorLevelUpgradeCost();
    if (score >= cost) {
        addScore(-cost);
        autoGeneratorLevel++;
        updateScoreDisplay();
        updateUpgradeButtons();
        saveGame();
        checkAllAchievements();
    } else {
        animateClickFeedback("Not enough points!", upgradeGeneratorLevelButton, true);
    }
}

function buyAutoGenerator() {
    if (autoGeneratorLevel > 0) {
        console.log("Auto Generator already purchased.");
        return; // Already bought
    }

    // Cost is 0 for the first purchase
    const currentCost = 0;

    if (score >= currentCost) {
        // Deduct cost (which is 0 first time)
        addScore(-currentCost); // This will become relevant if cost changes
        score = Math.max(0, score); // Prevent negative score just in case
        updateScoreDisplay();

        // Activate generator
        autoGeneratorLevel = 1; // Mark as purchased
        startAutoGenerator();

        // Update button state
        updateUpgradeButtons();
        saveGame();
        checkAllAchievements();
        console.log("Auto Bean Dropper purchased!");
    } else {
        // Not enough points (shouldn't happen for free item, but good practice)
        console.log("Not enough points (this shouldn't happen for the free upgrade)");
    }
}

function startAutoGenerator() {
    if (isAutoGeneratorRunning) return; // Already running
    isAutoGeneratorRunning = true;
    autoGeneratorStartTime = Date.now();
    
    if (autoGeneratorAnimationId) {
        cancelAnimationFrame(autoGeneratorAnimationId);
    }
    autoGeneratorLoop();
}

function autoGeneratorLoop() {
    if (!isAutoGeneratorRunning || autoGeneratorLevel === 0) {
        stopAutoGenerator();
        return;
    }

    const now = Date.now();
    const elapsedTime = now - autoGeneratorStartTime;
    const progress = Math.min(elapsedTime / AUTO_GENERATOR_INTERVAL_MS, 1);

    // Update progress bar UI
    if (dropperProgressBar) {
        dropperProgressBar.style.width = `${progress * 100}%`;
    }

    if (elapsedTime >= AUTO_GENERATOR_INTERVAL_MS) {
        spawnItem(autoGeneratorLevel); // Spawn a bean of the generator's current level
        autoGeneratorStartTime = now; // Reset timer for the next cycle
    }

    autoGeneratorAnimationId = requestAnimationFrame(autoGeneratorLoop);
}

function stopAutoGenerator() {
    isAutoGeneratorRunning = false;
    if (autoGeneratorAnimationId) {
        cancelAnimationFrame(autoGeneratorAnimationId);
        autoGeneratorAnimationId = null;
    }
    if (dropperProgressBar) {
        dropperProgressBar.style.width = '0%';
    }
}

function runAutoSell() {
    if (!hasAutoSeller || !autoSellLevel || isHardMode) return;

    // Use a copy of keys to avoid issues while modifying the boardItems map
    const slotIds = Object.keys(boardItems);

    for (const slotId of slotIds) {
        const item = boardItems[slotId];
        // Check if item exists and is less than or equal to the auto-sell level
        if (item && item.level <= autoSellLevel) {
            const sellPrice = Math.floor((ITEM_SELL_PRICES[item.level] || 0) * sellPriceMultiplier);
            addScore(sellPrice);
            stats.itemsSold++;
            
            // Animate feedback near the slot before it's removed
            const slotElement = document.getElementById(slotId);
            if(slotElement) {
                animateClickFeedback(`+${formatNumber(sellPrice)}`, slotElement);
            }
            
            playSound('sell.mp3');
            removeItem(slotId);
        }
    }
    saveGame();
    checkAllAchievements();
    updateScoreDisplay(); // Final update after all potential sales
}

function runAutoMerge() {
    if (!isAutoMergeActive) return;

    let mergedInLoop;
    do {
        mergedInLoop = false;
        const levelsMap = {};

        // Group items by level
        for (let i = 0; i < currentBoardSize; i++) {
            const slotId = `slot-${i}`;
            const item = boardItems[slotId];
            if (item) {
                if (!levelsMap[item.level]) {
                    levelsMap[item.level] = [];
                }
                levelsMap[item.level].push(slotId);
            }
        }

        // Find pairs and merge
        for (const level in levelsMap) {
            // Check if level is mergeable
            if (parseInt(level) >= MAX_ITEM_LEVEL) continue;

            const slots = levelsMap[level];
            if (slots.length >= 2) {
                // Merge the first two found
                // We merge into the one with the higher slot index to keep items generally at the 'end' of the board
                const slot1_index = parseInt(slots[0].split('-')[1]);
                const slot2_index = parseInt(slots[1].split('-')[1]);
                
                const sourceSlotId = slot1_index < slot2_index ? slots[0] : slots[1];
                const targetSlotId = slot1_index < slot2_index ? slots[1] : slots[0];

                if (mergeItems(sourceSlotId, targetSlotId)) {
                    mergedInLoop = true;
                    // Break out of the inner for...in loop to restart the whole process,
                    // because the board state has changed and levelsMap is now invalid.
                    break;
                }
            }
        }
    } while (mergedInLoop); // Keep running as long as merges are happening in a full pass
}

function populateAutoSellDropdown() {
    autoSellLevelSelect.innerHTML = '';
    
    // Add an "Off" option
    const offOption = document.createElement('option');
    offOption.value = 0;
    offOption.textContent = 'Off';
    autoSellLevelSelect.appendChild(offOption);
    
    for (let i = 1; i <= MAX_ITEM_LEVEL; i++) { // Loop up to and including MAX_ITEM_LEVEL
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Level ${i}`;
        autoSellLevelSelect.appendChild(option);
    }
    autoSellLevelSelect.value = autoSellLevel; // Set to current saved level
}

function updateUpgradeButtons() {
    // Auto Generator Button
    if (autoGeneratorLevel > 0) {
        autoGeneratorUpgradeButton.style.display = 'none'; // Hide initial purchase button
        autoGeneratorStatusContainer.style.display = 'flex'; // Show status display
        upgradeGeneratorLevelButton.style.display = 'inline-block'; // Show upgrade button
        dropperProgressContainer.style.display = 'block'; // Show progress bar over board

        autoGeneratorLevelDisplay.textContent = autoGeneratorLevel;

        const cost = getGeneratorLevelUpgradeCost();
        const nextLevel = autoGeneratorLevel + 1;
        if (nextLevel > MAX_ITEM_LEVEL) {
            upgradeGeneratorLevelButton.textContent = `Dropper MAX Level (Lvl ${autoGeneratorLevel})`;
            upgradeGeneratorLevelButton.disabled = true;
        } else {
            upgradeGeneratorLevelButton.textContent = `Upgrade Dropper to Lvl ${nextLevel} (${formatNumber(cost)} Pts)`;
            upgradeGeneratorLevelButton.disabled = score < cost;
        }
    } else {
        autoGeneratorUpgradeButton.style.display = 'inline-block';
        autoGeneratorStatusContainer.style.display = 'none'; // Hide status display
        upgradeGeneratorLevelButton.style.display = 'none';
        dropperProgressContainer.style.display = 'none'; // Hide progress bar
        autoGeneratorUpgradeButton.textContent = `Get FREE Auto Bean Dropper!`;
        autoGeneratorUpgradeButton.disabled = false;
    }

    // Clicker Level Upgrade Button (Hard Mode check)
    if (isHardMode) {
        upgradeClickLevelButton.style.display = 'none';
    } else {
        upgradeClickLevelButton.style.display = 'inline-block';
        const nextClickerLevel = clickerLevel + 1;
        if (nextClickerLevel > MAX_ITEM_LEVEL) {
            upgradeClickLevelButton.textContent = `Clicker MAX Level (Lvl ${clickerLevel})`;
            upgradeClickLevelButton.disabled = true;
        } else {
            const clickerCost = getClickerLevelUpgradeCost();
            upgradeClickLevelButton.textContent = `Upgrade Clicker to Lvl ${nextClickerLevel} (${formatNumber(clickerCost)} Pts)`;
            upgradeClickLevelButton.disabled = score < clickerCost;
        }
    }

    // Buy Slot Button
    if (currentBoardSize >= MAX_BOARD_SIZE) {
        buySlotUpgradeButton.textContent = 'Max Slots Reached';
        buySlotUpgradeButton.disabled = true;
    } else {
        const cost = getSlotUpgradeCost();
        buySlotUpgradeButton.textContent = `Buy New Slot (${formatNumber(cost)} Pts)`;
        buySlotUpgradeButton.disabled = score < cost;
    }

    // Auto Merger Button
    if (hasAutoMerger) {
        buyAutoMergerButton.style.display = 'none';
        autoMergerToggleContainer.style.display = 'flex';
    } else {
        buyAutoMergerButton.style.display = 'inline-block';
        autoMergerToggleContainer.style.display = 'none';
        buyAutoMergerButton.textContent = `Buy Auto-Merger (${formatNumber(AUTO_MERGER_COST)} Pts)`;
        buyAutoMergerButton.disabled = score < AUTO_MERGER_COST;
    }

    // Auto Seller Button (Hard Mode check)
    if (isHardMode) {
        buyAutoSellerButton.style.display = 'none';
        autoSellerContainer.style.display = 'none';
    } else if (hasAutoSeller) {
        buyAutoSellerButton.style.display = 'none';
        autoSellerContainer.style.display = 'flex';
        populateAutoSellDropdown();
    } else {
        buyAutoSellerButton.style.display = 'inline-block';
        autoSellerContainer.style.display = 'none';
        buyAutoSellerButton.textContent = `Buy Auto-Seller (${formatNumber(AUTO_SELLER_COST)} Pts)`;
        buyAutoSellerButton.disabled = score < AUTO_SELLER_COST;
    }

    // Quality Upgrade Button
    const qualityCost = getQualityUpgradeCost();
    qualityUpgradeButton.textContent = `Improve Quality (+5% Sell) (${formatNumber(qualityCost)} Pts)`;
    qualityUpgradeButton.disabled = score < qualityCost;

    // CPS Upgrade Button
    const cpsCost = getCpsUpgradeCost();
    cpsUpgradeButton.textContent = `Barista Training (+5% CPS) (${formatNumber(cpsCost)} Pts)`;
    cpsUpgradeButton.disabled = score < cpsCost;

    // Update clicker button state based on cost & hard mode
    clickerButton.disabled = (score < getClickCost()) || isHardMode;
}

// --- Achievements ---

function checkAllAchievements() {
    for (const id in ACHIEVEMENTS) {
        if (!unlockedAchievements.has(id)) {
            const achievement = ACHIEVEMENTS[id];
            if (achievement.check()) {
                unlockAchievement(id);
            }
        }
    }
}

function unlockAchievement(id) {
    unlockedAchievements.add(id);
    const achievement = ACHIEVEMENTS[id];
    console.log(`Achievement Unlocked: ${achievement.name}`);
    showAchievementToast(achievement);
    saveGame(); // Save progress when an achievement is unlocked
}

function showAchievementToast(achievement) {
    const toast = document.createElement('div');
    toast.classList.add('achievement-toast');
    toast.innerHTML = `
        <div class="toast-icon">🏆</div>
        <div class="toast-text">
            <h4>Achievement Unlocked!</h4>
            <p>${achievement.name}</p>
        </div>
    `;
    achievementToastContainer.appendChild(toast);

    setTimeout(() => {
        toast.remove();
    }, 4000); // Remove after 4 seconds
}

function openAchievementsModal() {
    achievementsList.innerHTML = ''; // Clear previous list

    Object.entries(ACHIEVEMENTS).forEach(([id, achievement]) => {
        const isUnlocked = unlockedAchievements.has(id);
        const item = document.createElement('div');
        item.classList.add('achievement-item');
        if (isUnlocked) {
            item.classList.add('unlocked');
        }

        item.innerHTML = `
            <div class="achievement-icon">${isUnlocked ? '🏆' : '❓'}</div>
            <div class="achievement-details">
                <h3 class="achievement-name">${isUnlocked ? achievement.name : 'Locked Achievement'}</h3>
                <p class="achievement-desc">${isUnlocked ? achievement.description : '??????????'}</p>
            </div>
        `;
        achievementsList.appendChild(item);
    });

    achievementsModal.style.display = 'block';
}

function closeAchievementsModal() {
    achievementsModal.style.display = 'none';
}

// --- Utility Functions ---

function formatNumber(num) {
    if (num === undefined || num === null) return '0';
    if (num < 1000) {
        return Math.floor(num).toString();
    }

    const suffixes = [
        { value: 1e3, symbol: "K" },
        { value: 1e6, symbol: "M" },
        { value: 1e9, symbol: "B" },
        { value: 1e12, symbol: "T" },
        { value: 1e15, symbol: "Qa" },
        { value: 1e18, symbol: "Qi" },
        { value: 1e21, symbol: "Sx" },
        { value: 1e24, symbol: "Sp" },
        { value: 1e27, symbol: "Oc" },
        { value: 1e30, symbol: "No" },
        { value: 1e33, symbol: "Dc" },
        { value: 1e36, symbol: "Ud" },
        { value: 1e39, symbol: "Dd" },
        { value: 1e42, symbol: "Td" },
        { value: 1e45, symbol: "Qad" }
    ];

    const item = suffixes.slice().reverse().find(item => num >= item.value);

    if (item) {
        const val = num / item.value;
        let precision = 2;
        if (val >= 100) {
            precision = 0;
        } else if (val >= 10) {
            precision = 1;
        }
        return val.toFixed(precision) + item.symbol;
    }
    
    return Math.floor(num).toLocaleString();
}

function animateClickFeedback(text, element = clickerButton, isGlobal = false) {
    const feedback = document.createElement('div');
    feedback.classList.add('click-feedback');
    feedback.textContent = text;

    if (isGlobal) {
        // Position relative to a fixed container for UI elements like buttons/sell zone
        const rect = element.getBoundingClientRect();
        const containerRect = clickFeedbackContainer.getBoundingClientRect();

        const top = rect.top - containerRect.top + (rect.height / 2) - 10;
        const left = rect.left - containerRect.left + (rect.width / 2);

        feedback.style.top = `${top}px`;
        feedback.style.left = `${left}px`;
        feedback.style.transform = 'translateX(-50%)';
        clickFeedbackContainer.appendChild(feedback);
    } else {
        // Position relative to the element itself (for board items)
        element.style.position = 'relative'; // Ensure the element can be a parent
        feedback.style.position = 'absolute';
        feedback.style.top = '50%';
        feedback.style.left = '50%';
        feedback.style.transform = 'translate(-50%, -50%)';
        element.appendChild(feedback);
    }

    // Remove the feedback element after animation
    feedback.addEventListener('animationend', () => {
        feedback.remove();
    });
}

function shootConfetti(element) {
     const rect = element.getBoundingClientRect();
     const origin = {
        x: (rect.left + rect.width / 2) / window.innerWidth,
        y: (rect.top + rect.height / 2) / window.innerHeight
     };

     confetti({
        particleCount: 50,
        spread: 70,
        origin: origin,
        scalar: 0.8 // Smaller confetti
     });
}

// --- Persistence (Local Storage) ---
const SAVE_KEY = 'coffeeClickerMergeSave';

function saveGame() {
    const gameState = {
        score: score,
        boardItems: boardItems,
        nextItemId: nextItemId,
        autoGeneratorLevel: autoGeneratorLevel,
        currentBoardSize: currentBoardSize,
        isHardMode: isHardMode,
        hasAutoMerger: hasAutoMerger,
        isAutoMergeActive: isAutoMergeActive,
        hasAutoSeller: hasAutoSeller,
        autoSellLevel: autoSellLevel,
        qualityUpgradeLevel: qualityUpgradeLevel,
        sellPriceMultiplier: sellPriceMultiplier,
        cpsUpgradeLevel: cpsUpgradeLevel,
        cpsMultiplier: cpsMultiplier,
        clickerLevel: clickerLevel,
        stats: stats,
        unlockedAchievements: Array.from(unlockedAchievements), // Convert Set to Array for JSON
        theme: currentTheme
    };
    try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
         // console.log("Game saved");
    } catch (e) {
        console.error("Failed to save game:", e);
    }
}

function loadGame() {
    const savedState = localStorage.getItem(SAVE_KEY);
    if (savedState) {
        try {
            const gameState = JSON.parse(savedState);
            score = gameState.score !== undefined ? gameState.score : 100;
            boardItems = gameState.boardItems || {};
            nextItemId = gameState.nextItemId || 0;
            autoGeneratorLevel = gameState.autoGeneratorLevel || 0;
            currentBoardSize = gameState.currentBoardSize || 12;
            isHardMode = gameState.isHardMode || false;
            hasAutoMerger = gameState.hasAutoMerger || false;
            // Respect saved toggle state, default to true if they have the upgrade but no saved state for it
            isAutoMergeActive = gameState.isAutoMergeActive !== undefined ? gameState.isAutoMergeActive : hasAutoMerger;
            autoMergerToggle.checked = isAutoMergeActive;
            
            hasAutoSeller = gameState.hasAutoSeller || false;
            autoSellLevel = gameState.autoSellLevel || 1;
            qualityUpgradeLevel = gameState.qualityUpgradeLevel || 0;
            sellPriceMultiplier = gameState.sellPriceMultiplier || 1.0;
            cpsUpgradeLevel = gameState.cpsUpgradeLevel || 0;
            cpsMultiplier = gameState.cpsMultiplier || 1.0;
            clickerLevel = gameState.clickerLevel || 1;
            stats = gameState.stats || { clicks: 0, merges: 0, itemsSold: 0, highestLevelReached: 0 };
            unlockedAchievements = new Set(gameState.unlockedAchievements || []);
            currentTheme = gameState.theme || 'light';

            // Apply theme from save
            applyTheme(currentTheme);

            // Re-render items from loaded state
            createBoardSlots(); // Create correct number of slots first
            renderAllItems(); // Then render the items into them
            
            console.log("Game loaded");

        } catch (e) {
            console.error("Failed to load game:", e);
            // Initialize with defaults if loading fails
            resetGameState();
        }
    } else {
         // Initialize with defaults if no save exists
         resetGameState();
    }
    updateModeDisplay(); // Make sure visual mode indicator is correct on load
     updateScoreDisplay();
     updateCPSDisplay();
     updateUpgradeButtons(); // Update button state based on loaded data
}

function resetGameState() {
    score = 100;
    boardItems = {};
    nextItemId = 0;
    autoGeneratorLevel = 0;
    stopAutoGenerator(); // Ensure the loop is stopped
    currentBoardSize = 12;
    // Note: isHardMode is NOT reset here, it's handled by the calling function (performReset/toggleHardMode)
    hasAutoMerger = false;
    isAutoMergeActive = false;
    hasAutoSeller = false;
    autoSellLevel = 1;
    qualityUpgradeLevel = 0;
    sellPriceMultiplier = 1.0;
    cpsUpgradeLevel = 0;
    cpsMultiplier = 1.0;
    clickerLevel = 1;
    unlockedAchievements = new Set();
    stats = { clicks: 0, merges: 0, itemsSold: 0, highestLevelReached: 0 };
    // Theme is not reset with game progress, it's a UI preference.

    // Clear and recreate board
    mergeBoard.innerHTML = '';
    createBoardSlots();
}

// --- Start the game ---
initGame();
